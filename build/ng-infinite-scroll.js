// Generated by CoffeeScript 1.10.0
(function() {
  var mod;

  mod = angular.module('infinite-scroll', []);

  mod.value('THROTTLE_MILLISECONDS', null);

  mod.directive('infiniteScroll', [
    '$rootScope', '$window', '$timeout', 'THROTTLE_MILLISECONDS', function($rootScope, $window, $timeout, THROTTLE_MILLISECONDS) {
      return {
        scope: {
          infiniteScroll: '&',
          infiniteScrollContainer: '=',
          infiniteScrollDistance: '=',
          infiniteScrollDisabled: '=',
          infiniteScrollUseDocumentBottom: '=',
          infiniteScrollHorizontal: '='
        },
        link: function(scope, elem, attrs) {
          var changeContainer, checkWhenEnabled, container, handleInfiniteScrollContainer, handleInfiniteScrollDisabled, handleInfiniteScrollDistance, handleInfiniteScrollHorizontal, handleInfiniteScrollUseDocumentBottom, handler, height, immediateCheck, offsetLeft, offsetTop, pageXOffset, pageYOffset, scrollDistance, scrollEnabled, scrollHorizontal, throttle, useDocumentBottom, width, windowElement;
          windowElement = angular.element($window);
          scrollDistance = null;
          scrollEnabled = null;
          checkWhenEnabled = null;
          container = null;
          immediateCheck = true;
          useDocumentBottom = false;
          scrollHorizontal = false;
          height = function(elem) {
            elem = elem[0] || elem;
            if (isNaN(elem.offsetHeight)) {
              return elem.document.documentElement.clientHeight;
            } else {
              return elem.offsetHeight;
            }
          };
          width = function(elem) {
            elem = elem[0] || elem;
            if (isNaN(elem.offsetWidth)) {
              return elem.document.documentElement.clientWidth;
            } else {
              return elem.offsetWidth;
            }
          };
          offsetTop = function(elem) {
            if (!elem[0].getBoundingClientRect || elem.css('none')) {
              return;
            }
            return elem[0].getBoundingClientRect().top + pageYOffset(elem);
          };
          offsetLeft = function(elem) {
            if (!elem[0].getBoundingClientRect || elem.css('none')) {
              return;
            }
            return elem[0].getBoundingClientRect().left + pageXOffset(elem);
          };
          pageYOffset = function(elem) {
            elem = elem[0] || elem;
            if (isNaN(window.pageYOffset)) {
              return elem.document.documentElement.scrollTop;
            } else {
              return elem.ownerDocument.defaultView.pageYOffset;
            }
          };
          pageXOffset = function(elem) {
            elem = elem[0] || elem;
            if (isNaN(window.pageXOffset)) {
              return elem.document.documentElement.scrollLeft;
            } else {
              return elem.ownerDocument.defaultView.pageXOffset;
            }
          };
          handler = function() {
            var containerBottom, containerTopOffset, elementBottom, remaining, shouldScroll;
            if (container === windowElement) {
              if (scrollHorizontal) {
                containerBottom = width(container) + pageXOffset(container[0].document.documentElement);
                elementBottom = offsetLeft(elem) + width(elem);
              } else {
                containerBottom = height(container) + pageYOffset(container[0].document.documentElement);
                elementBottom = offsetTop(elem) + height(elem);
              }
            } else {
              containerBottom = scrollHorizontal ? width(container) : height(container);
              containerTopOffset = 0;
              if (offsetTop(container) !== void 0) {
                containerTopOffset = scrollHorizontal ? offsetLeft(container) : offsetTop(container);
                if (scrollHorizontal) {
                  elementBottom = offsetLeft(elem) - containerTopOffset + width(elem);
                } else {
                  elementBottom = offsetTop(elem) - containerTopOffset + height(elem);
                }
              }
            }
            if (useDocumentBottom) {
              if (scrollHorizontal) {
                elementBottom = width((elem[0].ownerDocument || elem[0].document).documentElement);
              } else {
                elementBottom = height((elem[0].ownerDocument || elem[0].document).documentElement);
              }
            }
            remaining = elementBottom - containerBottom;
            if (scrollHorizontal) {
              shouldScroll = remaining <= width(container) * scrollDistance + 1;
            } else {
              shouldScroll = remaining <= height(container) * scrollDistance + 1;
            }
            if (shouldScroll) {
              checkWhenEnabled = true;
              if (scrollEnabled) {
                if (scope.$$phase || $rootScope.$$phase) {
                  return scope.infiniteScroll();
                } else {
                  return scope.$apply(scope.infiniteScroll);
                }
              }
            } else {
              return checkWhenEnabled = false;
            }
          };
          throttle = function(func, wait) {
            var later, previous, timeout;
            timeout = null;
            previous = 0;
            later = function() {
              var context;
              previous = new Date().getTime();
              $timeout.cancel(timeout);
              timeout = null;
              func.call();
              return context = null;
            };
            return function() {
              var now, remaining;
              now = new Date().getTime();
              remaining = wait - (now - previous);
              if (remaining <= 0) {
                clearTimeout(timeout);
                $timeout.cancel(timeout);
                timeout = null;
                previous = now;
                return func.call();
              } else {
                if (!timeout) {
                  return timeout = $timeout(later, remaining);
                }
              }
            };
          };
          if (THROTTLE_MILLISECONDS != null) {
            handler = throttle(handler, THROTTLE_MILLISECONDS);
          }
          scope.$on('$destroy', function() {
            return container.off('scroll', handler);
          });
          handleInfiniteScrollHorizontal = function(v) {
            return scrollHorizontal = v;
          };
          scope.$watch('infiniteScrollHorizontal', handleInfiniteScrollHorizontal);
          handleInfiniteScrollHorizontal(scope.infiniteScrollHorizontal);
          handleInfiniteScrollDistance = function(v) {
            return scrollDistance = parseFloat(v) || 0;
          };
          scope.$watch('infiniteScrollDistance', handleInfiniteScrollDistance);
          handleInfiniteScrollDistance(scope.infiniteScrollDistance);
          handleInfiniteScrollDisabled = function(v) {
            scrollEnabled = !v;
            if (scrollEnabled && checkWhenEnabled) {
              checkWhenEnabled = false;
              return handler();
            }
          };
          scope.$watch('infiniteScrollDisabled', handleInfiniteScrollDisabled);
          handleInfiniteScrollDisabled(scope.infiniteScrollDisabled);
          handleInfiniteScrollUseDocumentBottom = function(v) {
            return useDocumentBottom = v;
          };
          scope.$watch('infiniteScrollUseDocumentBottom', handleInfiniteScrollUseDocumentBottom);
          handleInfiniteScrollUseDocumentBottom(scope.infiniteScrollUseDocumentBottom);
          changeContainer = function(newContainer) {
            if (container != null) {
              container.off('scroll', handler);
            }
            container = typeof newContainer.last === 'function' && newContainer !== windowElement ? newContainer.last() : newContainer;
            if (newContainer != null) {
              return container.on('scroll', handler);
            }
          };
          changeContainer(windowElement);
          handleInfiniteScrollContainer = function(newContainer) {
            if ((newContainer == null) || newContainer.length === 0) {
              return;
            }
            newContainer = angular.element(document.querySelector(newContainer));
            if (newContainer != null) {
              return changeContainer(newContainer);
            } else {
              throw new Exception("invalid infinite-scroll-container attribute.");
            }
          };
          scope.$watch('infiniteScrollContainer', handleInfiniteScrollContainer);
          handleInfiniteScrollContainer(scope.infiniteScrollContainer || []);
          if (attrs.infiniteScrollParent != null) {
            changeContainer(angular.element(elem.parent()));
          }
          if (attrs.infiniteScrollImmediateCheck != null) {
            immediateCheck = scope.$eval(attrs.infiniteScrollImmediateCheck);
          }
          return $timeout((function() {
            if (immediateCheck) {
              return handler();
            }
          }), 0);
        }
      };
    }
  ]);

}).call(this);
